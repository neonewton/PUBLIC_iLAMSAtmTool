#!/usr/local/bin/python3

"""

## SETUP / Checklist

# Create virtual environment (replace `venv` with your preferred folder)
python3 -m venv venv

# Activate (macOS/Linux)
source venv/bin/activate

# Activate (Windows)
venv\Scripts\activate

# Check Python Version
python3 -V

# Install Required Packages
pip install -r requirements.txt

# Python Interpreter
Make sure your script uses the correct Python interpreter path:
#!/usr/local/bin/python3
In VS Code, use ⇧ + ⌘ + P → “Python: Select Interpreter” and choose Python 3.13 manually.

⚠️ Avoid using:
#!/usr/bin/env python3


"""
# Ensure you have started Chrome with:
r"""
MAC:
open -a "Google Chrome" --args \
  --remote-debugging-port=9222 \
  --user-data-dir="$HOME/chrome-debug-profile"
then
curl http://127.0.0.1:9222/json
WINDOWS:
& 'C:\Program Files\Google\Chrome\Application\chrome.exe' `
  --remote-debugging-port=9222 `
  --user-data-dir="C:\Users\Neone\chrome-debug-profile"
then
curl http://127.0.0.1:9222/json

"""

import sys, os, threading, time
from datetime import datetime
import tkinter as tk
#from tkinter import ttk
from tkinter import messagebox, filedialog
from tkinter.scrolledtext import ScrolledText
import pandas as pd
import xlwt # for .xls output
from pathlib import Path
import pyexcel
import pyexcel_xlsx
from ttkbootstrap import ttk , Style, Window
from ttkbootstrap.constants import *

import re
import io
import csv
import unicodedata
from docx import Document
from docx.shared import Pt, Inches
from docx.oxml.ns import qn
from PIL import Image
import requests, json

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import TimeoutException

if os.name == "nt":        # Windows
    os.system("cls")
else:                      # Linux / macOS
    os.system("clear")

import time


"""
# 1) Path to your matching ChromeDriver
chrome_driver_path = r"C:\\Users\\Neone\\Driver\\chromedriver.exe"  
service = Service(chrome_driver_path)

# 2) Tell Selenium to hook into the existing Chrome debug port
options = Options()
options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")

# 3) Create the driver (this will *not* open a new browser window)
driver = webdriver.Chrome(service=service, options=options)

# 4) Confirm it s attached by printing the current title and URL
print("Attached to browser:", driver.title, driver.current_url)

"""
# Check which Python interpreter is in use
print("Using Python executable:", sys.executable)
print("⏳ Waiting for user input ⏳")

#global Elentra_Event_entry, LAMS_Lesson_ID_entry, LAMS_Lesson_Title_entry, Upload_Monitor_URL_checkbox, Upload_Student_URL_checkbox

# ---- UI Global Log Universal logger function ----
def log(msg, newline=True):
    log_widget.config(state='normal')
    log_widget.insert('end', msg + ('\n' if newline else ''))
    log_widget.see('end')
    log_widget.config(state='disabled')
    root.update_idletasks()

# ---- Constants for Excel ----
STUDENT_HEADERS = ["* login", "* organisation", "* roles","* add to lessons [yes/no]",""]
STAFF_HEADERS   = ["* login", "* organisation", "* roles", "* add to lessons [yes/no]",""]

def parse_emails(text):
    emails = []
    for line in text.splitlines():
        for part in line.split(','):
            email = part.strip()
            if email:
                emails.append(email)
    return emails

def save_xls(folder, filename, headers, rows):
    wb = xlwt.Workbook()
    ws = wb.add_sheet('Sheet1')
    for col, h in enumerate(headers): ws.write(0, col, h)
    for r, row in enumerate(rows, start=1):
        for c, val in enumerate(row): ws.write(r, c, val)
    path = os.path.join(folder, filename)
    wb.save(path)
    return path

def build_student_file(folder, course_name, course_id, emails, role_entry, add_info_text):
    """
    One file, many emails all tied to the same course_id.
    """
    today = datetime.now().strftime("%d%m%y")
    rows = [
        # each row: [email, course_id, role, upload_flag, extra_info]
        [email, course_id, role_entry, "Yes", add_info_text]
        for email in emails
    ]
    fname = f"{course_name}_CID{course_id}_{today}.xls"
    return save_xls(folder, fname, STUDENT_HEADERS, rows)

def build_staff_files(folder, department, course_ids, emails, role_entry, add_infos):
    """
    One file per staff email; each file contains multiple rows,
    one per course_id.
    """
    today = datetime.now().strftime("%d%m%y")
    files = []
    for email in emails:
        rows = [
            # (for each course, pull its matching add_info)
            [email, cid, role_entry, "Yes", info]
            for cid, info in zip(course_ids, add_infos)
        ]
        # safe-filename the email if needed, or strip “@” / “.” etc
        safe_email = email.replace("@ntu.edu.sg", "").replace("@email.com","")
        fname = f"{department}_{safe_email}_{today}.xls"
        files.append(save_xls(folder, fname, STAFF_HEADERS, rows))
    return files

# ---- UI Tkinter Setup ----
#root = tk.Tk()
root = Window(themename="cosmo") 
style = Style(theme="cosmo")

root.title("iLAMS Automation Tool")

#branding colour purple
style.configure("secondary.TButton", background="#5C004D", foreground="#ffffff")
style.configure("secondary.TCheckbutton", background="#5C004D", foreground="#ffffff")
style.configure("secondary.TLabel", background="#5C004D", foreground="#ffffff")


today_2 = datetime.now().strftime("%d%m%y")
# for simplicity, will direct the save dir to user's downloads folder
home = os.path.expanduser("~")
downloads = os.path.join(home, "Downloads", f"User Excel Generation_{today_2}")
# for testing purpose, we use source code folder
script_dir = os.path.dirname(os.path.abspath(__file__))
output_folder = os.path.join(script_dir, os.pardir, "3 data")
os.makedirs(output_folder, exist_ok=True)


# --- TTK Notebook for Tabs ---
notebook = ttk.Notebook(root)
notebook.grid(row=0, column=0, sticky="nsew")
root.grid_rowconfigure(0, weight=0)   # notebook row no longer expands
root.grid_rowconfigure(5, weight=1)   # log row soaks up all extra space
root.grid_columnconfigure(0, weight=1)
root.grid_columnconfigure(1, weight=1)
root.grid_columnconfigure(2, weight=1)


excel_frame   = ttk.Frame(notebook, padding=5)
combine_frame  = ttk.Frame(notebook, padding=5)
selenium_frame= ttk.Frame(notebook, padding=5)
about_frame= ttk.Frame(notebook, padding=5)
formatter_frame = ttk.Frame(notebook, padding=5)

#Order
notebook.add(formatter_frame, text="SoT → LAMS Formatter")
notebook.add(selenium_frame, text="Elentra Link Upload")
notebook.add(excel_frame, text="User Excel Generation")
notebook.add(combine_frame, text="User Excel Combination")
#notebook.add(about_frame, text="About")

# ---- Global widgets for later disable/enable ----
global_buttons = []

# --- Control variables
mode_var    = tk.StringVar(value='staff')
header_var  = tk.StringVar()
output_folder_excel = os.path.join(script_dir, os.pardir, "3 data", f"LAMS User Excel Generation_{today_2}")
save_dir_var = tk.StringVar(value=output_folder_excel)
combine_dir_var = tk.StringVar(value=output_folder_excel)

btn_opts = dict(padx=5, pady=8) # padding of function buttons

# --- Grid options for Excel tab
excel_row_int = 0
excel_grid_opts = {
    'title_label':          dict(row=excel_row_int+0, column=0, columnspan=3, padx=10, pady=4, sticky='w'),
    'instruction_label':    dict(row=excel_row_int+1, column=0, columnspan=3, padx=10, pady=4, sticky='w'),
    'mode_staff_rb':        dict(row=excel_row_int+2, column=0, padx=8, pady=4, sticky='w'),
    'mode_student_rb':      dict(row=excel_row_int+2, column=1, padx=8, pady=4, sticky='w'),
    #'save_label':           dict(row=excel_row_int+3, column=0, sticky='e', padx=4),
    # 'browse_btn':           dict(row=excel_row_int+3, column=0, sticky= 'ew', padx=4, pady=4),
    # 'save_entry':           dict(row=excel_row_int+4, column=0, columnspan=2, sticky='ew', padx=4, pady=4),
    'browse_btn':           dict(row=excel_row_int+3, column=0, sticky= 'ew', padx=4, pady=4),
    'save_entry':           dict(row=excel_row_int+3, column=1, columnspan=2, sticky='ew', padx=4, pady=4),
    'header_text_label':    dict(row=excel_row_int+5, column=0, sticky='ne', padx=4),
    'header_label':         dict(row=excel_row_int+5, column=1, columnspan=2, sticky='w'),
    'emails_label':         dict(row=excel_row_int+6, column=0, sticky='ne', padx=4, pady=4),
    'emails_text':          dict(row=excel_row_int+6, column=1, columnspan=2, sticky='nsew', pady=4),
    'courseid_label':       dict(row=excel_row_int+7, column=0, sticky='ne', padx=4, pady=4),
    'courseid_text':        dict(row=excel_row_int+7, column=1, columnspan=2, sticky='nsew', pady=4),
    'add_info_label':       dict(row=excel_row_int+8, column=0, sticky='ne', padx=4, pady=4),
    'add_info_entry':       dict(row=excel_row_int+8, column=1, columnspan=2, sticky='nsew', pady=4),
    'coursename_label':     dict(row=excel_row_int+9, column=0, sticky='e', padx=4),
    'coursename_entry':     dict(row=excel_row_int+9, column=1, columnspan=2, sticky='ew', pady=4),
    'dept_label':           dict(row=excel_row_int+10, column=0, sticky='e', padx=4),
    'dept_entry':           dict(row=excel_row_int+10, column=1, columnspan=2, sticky='ew', pady=4),
    'role_label':           dict(row=excel_row_int+11, column=0, sticky='e', padx=4),
    'role_entry':           dict(row=excel_row_int+11, column=1, columnspan=2, sticky='ew', pady=4),
    'role_sample_label':    dict(row=excel_row_int+12, column=0, sticky='e', padx=4),
    'role_sample':          dict(row=excel_row_int+12, column=1, sticky='w', padx=0),
    'excel_btn_frame':      dict(row=excel_row_int+13, column=0, columnspan=3, sticky='w', pady=20)
}

sample_course_id_text="629\n630\n631\n632\n633\n634\n635\n636\n637"
sample_course_name_text="LKC TESTING SANDBOX 2025/2026\nCohort_2025Y1\nCohort_2024Y2\nCohort_2023Y3_Misc\nCohort_2023Y3_Posting_Quiz\nCohort_2023Y3_eModules\nCohort_2022Y4_Misc\nCohort_2022Y4_Posting_Quiz\nCohort_2021Y5_Misc"

###~~~~ GUI EXCEL TAB ~~~~###
tk.Label(excel_frame, text="Automated Generation of iLAMS User Excels", font=("Helvetic",14,"bold")).grid(**excel_grid_opts['title_label'])
tk.Label(excel_frame, text="Build the Staff or Student Excel file (.xlsx) for User Import in LAMS Admin.").grid(**excel_grid_opts['instruction_label'])
ttk.Radiobutton(excel_frame, bootstyle="info", text="Staff List", variable=mode_var, value='staff', command=lambda:switch_mode()).grid(**excel_grid_opts['mode_staff_rb'])
ttk.Radiobutton(excel_frame, bootstyle="info", text="Student List", variable=mode_var, value='student', command=lambda:switch_mode()).grid(**excel_grid_opts['mode_student_rb'])
#tk.Label(excel_frame, text="Save Folder:").grid(**excel_grid_opts['save_label'])

ttk.Button(excel_frame, style="secondary.Tbutton", text="Step 1: Browse..", command=lambda:select_folder(save_dir_var)).grid(**excel_grid_opts['browse_btn'])
tk.Entry(excel_frame, textvariable=save_dir_var).grid(**excel_grid_opts['save_entry'])
tk.Label(excel_frame, text="Header:").grid(**excel_grid_opts['header_text_label'])
tk.Label(excel_frame, textvariable=header_var, fg='dark gray').grid(**excel_grid_opts['header_label'])
tk.Label(excel_frame, text="Emails:").grid(**excel_grid_opts['emails_label'])
email_text = tk.Text(excel_frame, width=1, height=5); email_text.grid(**excel_grid_opts['emails_text'])
email_text.insert('1.0', "user1@email.com\nuser2@email.com\nuser3@email.com\nnelton.tan@ntu.edu.sg")
tk.Label(excel_frame, text="Course ID:").grid(**excel_grid_opts['courseid_label'])
course_id_text = tk.Text(excel_frame, width=1, height=5); course_id_text.grid(**excel_grid_opts['courseid_text']); 
#course_id_text.insert('1.0', sample_course_id_text)
tk.Label(excel_frame, text="Course Name:").grid(**excel_grid_opts['coursename_label'])
course_name_entry = tk.Entry(excel_frame, width=61); course_name_entry.grid(**excel_grid_opts['coursename_entry']); course_name_entry.insert(0, "CohortName")
tk.Label(excel_frame, text="Additional Info:").grid(**excel_grid_opts['add_info_label'])
add_info_text = tk.Text(excel_frame, width=1, height=5); add_info_text.grid(**excel_grid_opts['add_info_entry']); 
#add_info_text.insert('1.0', sample_course_name_text)
tk.Label(excel_frame, text="Department:").grid(**excel_grid_opts['dept_label'])
dept_entry = tk.Entry(excel_frame, width=61); dept_entry.grid(**excel_grid_opts['dept_entry']); 
dept_entry.insert(0, "DepartmentName")
tk.Label(excel_frame, text="Role:").grid(**excel_grid_opts['role_label'])
role_entry = tk.Entry(excel_frame, width=1); role_entry.grid(**excel_grid_opts['role_entry']); 
# role_entry.insert(0, 'Learner')
tk.Label(excel_frame, text="Roles available:").grid(**excel_grid_opts['role_sample_label'])
tk.Label(excel_frame, text="author|group manager|monitor|learner").grid(**excel_grid_opts['role_sample'])
excel_btn_frame = tk.Frame(excel_frame); 
excel_btn_frame.grid(**excel_grid_opts['excel_btn_frame'])
excel_btn_frame.grid_columnconfigure(0, weight=1); 
excel_btn_frame.grid_columnconfigure(2, weight=1)
excel_run_btn = ttk.Button(excel_btn_frame, style="secondary.Tbutton", text="Step 2: Run Excel", command=lambda:excel_run_threadsafe())
excel_run_btn.grid  (row=0, column=1, sticky='ew',**btn_opts)
#excel_close_btn.grid(row=0, column=2, **btn_opts)
#excel_close_btn = ttk.Button(btn_frame, bootstyle="dark-outline", text="Close Program", width=10, command=root.destroy)
global_buttons += [excel_run_btn]


###~~~~ GUI COMBINE TAB ~~~~###
combine_row_int = 0
combine_grid_opts = {
    'title_label':          dict(row=combine_row_int+0, column=0, columnspan=3, padx=10, pady=4, sticky='w'),
    'instruction_label':    dict(row=combine_row_int+1, column=0, columnspan=3, padx=10, pady=4, sticky='w'),
    'instruction_label2':    dict(row=combine_row_int+2, column=0, columnspan=3, padx=10, pady=4, sticky='w'),
    'folder_browse':        dict(row=combine_row_int+3, column=0, padx=4, pady=4, sticky='w'),
    'folder_entry':         dict(row=combine_row_int+3, column=1, columnspan=3, padx=8, pady=4, sticky='ew'),
    'Scan_btn':             dict(row=combine_row_int+4, column=0, columnspan=2, padx=4, pady=4, sticky='w'),
    'to_combine_log_box':    dict(row=combine_row_int+5, column=0, columnspan=3, padx=4, pady=4, sticky='ew'),
    'cmb_btn_frame':        dict(row=combine_row_int+8, column=0, columnspan=3, pady=20, sticky='w'),
    
}

root.grid_rowconfigure(0, weight=1)
root.grid_columnconfigure(0, weight=1)
root.grid_columnconfigure(1, weight=0)
root.grid_columnconfigure(2, weight=0)

# Title + instruction
tk.Label(combine_frame, text="Automated Combination of iLAMS User Excels", font=("Helvetic",14,"bold")).grid(**combine_grid_opts['title_label'])
tk.Label(combine_frame, text="Combine Staff or Student Excel file (.xls) for User Import in LAMS Admin.").grid(**combine_grid_opts['instruction_label'])
tk.Label(combine_frame, text="Select folder path containing .xls files, scan and then combine").grid(**combine_grid_opts['instruction_label2'])
# Folder picker
ttk.Button(combine_frame, style="secondary.Tbutton", text="Step 3: Browse and Scan .xls", command=lambda:scan_files_to_combine()).grid(**combine_grid_opts['folder_browse'])
tk.Entry(combine_frame, textvariable=combine_dir_var, width=45).grid(**combine_grid_opts['folder_entry'])
# “Scan files” button
#ttk.Button(combine_frame, style="secondary.Tbutton", text="Step 4: Scan .xls files", command=lambda: scan_files_to_combine()).grid(**combine_grid_opts['Scan_btn'])
# ScrolledText log area
to_combine_box = ScrolledText(combine_frame, wrap="word", width=45, height=15, state="disabled")
to_combine_box.grid(**combine_grid_opts['to_combine_log_box'])



# — Combine buttons (grid) —
cmb_btn_frame = tk.Frame(combine_frame); 
cmb_btn_frame.grid(**combine_grid_opts['cmb_btn_frame'])
cmb_btn_frame.grid_columnconfigure(0, weight=0); 
combine_start_btn = ttk.Button(cmb_btn_frame, style="secondary.Tbutton", text="Step 4: Combine !", command=lambda:combine_all_threadsafe())
combine_start_btn.grid(row=0, column=1, sticky='ew', **btn_opts)

global_buttons += [combine_start_btn]

###~~~~ GUI Elentra Link Upload TAB (Code #1) ~~~~###
sel_row_int = 0
sel_pad = dict(padx=8, pady=6)
sel_grid_opts = {
    'title_label':                  dict(row=sel_row_int+0, column=0, columnspan=3, padx=10, pady=4, sticky='w'),
    'instruction_label':            dict(row=sel_row_int+1, column=0, columnspan=3, padx=10, pady=4, sticky='w'),
    'instruction_box':              dict(row=sel_row_int+2, column=0, columnspan=3, padx=4, pady=4, sticky='ew'),
    'step':                         dict(row=sel_row_int+3, column=0, columnspan=3, padx=4, pady=4, sticky='w'),
    'Elentra_Event_ID':             dict(row=sel_row_int+6, column=0, padx=8, pady=4, sticky='e'),
    'Elentra_Event_entry':          dict(row=sel_row_int+6, column=1, padx=8, columnspan=3, pady=4, sticky='ew'),
    'LAMS_Lesson_ID':               dict(row=sel_row_int+5, column=0, padx=8, pady=4, sticky='e'),
    'LAMS_Lesson_ID_entry':         dict(row=sel_row_int+5, column=1, padx=8, columnspan=3, pady=4, sticky='ew'),
    'LAMS_Lesson_Title':            dict(row=sel_row_int+4, column=0, padx=8, pady=4, sticky='e'),
    'LAMS_Lesson_Title_entry':      dict(row=sel_row_int+4, column=1, padx=8, columnspan=3, pady=4, sticky='ew'),
    'Upload_Monitor_URL_checkbox':  dict(row=sel_row_int+7, column=0, columnspan=3, padx=8, pady=4, sticky='w'),
    'Upload_Student_URL_checkbox':  dict(row=sel_row_int+8, column=0, columnspan=3, padx=8, pady=4, sticky='w'),
    'sel_btn_frame':                dict(row=sel_row_int+10, column=0, columnspan=3, pady=20, sticky='w')
}

expandbox = tk.PanedWindow(selenium_frame, orient=tk.HORIZONTAL,sashrelief='raised')
expandbox.grid(**sel_grid_opts['instruction_box'])

instruction_mac_text = r"""
MAC:
open -a "Google Chrome" --args \\
    --remote-debugging-port=9222 \\
    --user-data-dir="$HOME/chrome-debug-profile"

then

curl http://127.0.0.1:9222/json
"""
instruction_win_text = r"""
WINDOWS:
& 'C:\Program Files\Google\Chrome\Application\chrome.exe' `
  --remote-debugging-port=9222 `
  --user-data-dir="C:\Users\Neone\chrome-debug-profile"

then

curl http://127.0.0.1:9222/json
"""
selenium_frame.grid_rowconfigure(sel_grid_opts['instruction_box']['row'], weight=0)
selenium_frame.grid_columnconfigure(0, weight=0)
selenium_frame.grid_columnconfigure(1, weight=1)
selenium_frame.grid_columnconfigure(2, weight=1)


tk.Label(selenium_frame, text="Automated iLAMS-to-Elentra Link Upload", font=("Helvetica",14,"bold")).grid(**sel_grid_opts['title_label'])
tk.Label(selenium_frame, text="Ensure you are logged into chrome and downloaded the webdriver before executing").grid(**sel_grid_opts['instruction_label'])
label_mac = tk.Text(expandbox, wrap="word", font=("Helvetica", 10), height=10, width=40, bd=0, padx=10, pady=8)
label_win = tk.Text(expandbox, wrap="word", font=("Helvetica", 10), height=10, width=50, bd=0, padx=10, pady=8)
label_mac.insert("1.0", instruction_mac_text)
label_win.insert("1.0", instruction_win_text)
label_mac.configure(state="disabled")
label_win.configure(state="disabled")
expandbox.add(label_mac)
expandbox.add(label_win)
ttk.Label(selenium_frame, style="secondary.TLabel", text="Step A: Input Parameters", font=("Helvetica",12)).grid(**sel_grid_opts['step'])
tk.Label(selenium_frame, text=" Elentra Event ID:", width=10).grid(**sel_grid_opts['Elentra_Event_ID'])
Elentra_Event_entry = tk.StringVar(value="1696")
Elentra_Event_label = tk.Entry(selenium_frame,textvariable=Elentra_Event_entry)
Elentra_Event_label.grid(**sel_grid_opts['Elentra_Event_entry'])
#Elentra_Event_entry.insert('1.0', "1696")
tk.Label(selenium_frame, text="LAMS Lesson ID:").grid(**sel_grid_opts['LAMS_Lesson_ID'])
LAMS_Lesson_ID_entry = tk.StringVar(value="37655")
LAMS_Lesson_ID_label = tk.Entry(selenium_frame, textvariable=LAMS_Lesson_ID_entry)
LAMS_Lesson_ID_label.grid(**sel_grid_opts['LAMS_Lesson_ID_entry'])
#LAMS_Lesson_ID_entry.insert('1.0', "37655")
tk.Label(selenium_frame, text="LAMS Lesson Title:").grid(**sel_grid_opts['LAMS_Lesson_Title'])
LAMS_Lesson_Title_entry = tk.StringVar(value="(RPA test)FM_MiniQuiz_WomanHealth_DDMMYY")
LAMS_Lesson_Title_label = tk.Entry(selenium_frame, textvariable=LAMS_Lesson_Title_entry)
LAMS_Lesson_Title_label.grid(**sel_grid_opts['LAMS_Lesson_Title_entry'])
#LAMS_Lesson_Title_entry.insert('1.0', "(RPA test)FM_MiniQuiz_WomanHealth_DDMMYY")
Upload_Monitor_URL_checkbox = tk.BooleanVar(value=True) 
#Upload_Monitor_URL_icon = ttk.Checkbutton(selenium_frame, style="secondary.TCheckbutton", text="Upload Monitor URL", variable=Upload_Monitor_URL_checkbox)
Upload_Monitor_URL_icon = ttk.Checkbutton(selenium_frame, bootstyle="info", text="Upload Monitor URL", variable=Upload_Monitor_URL_checkbox)
Upload_Monitor_URL_icon.grid(**sel_grid_opts['Upload_Monitor_URL_checkbox'])
Upload_Student_URL_checkbox = tk.BooleanVar(value=True) 
#Upload_Student_URL_icon = ttk.Checkbutton(selenium_frame, style="secondary.TCheckbutton", text="Upload Student URL", variable=Upload_Student_URL_checkbox)
Upload_Student_URL_icon = ttk.Checkbutton(selenium_frame, bootstyle="info", text="Upload Student URL", variable=Upload_Student_URL_checkbox)
Upload_Student_URL_icon.grid(**sel_grid_opts['Upload_Student_URL_checkbox'])


# — Selenium buttons —
sel_btn_frame = tk.Frame(selenium_frame); 
sel_btn_frame.grid(**sel_grid_opts['sel_btn_frame'])
sel_btn_frame.grid_columnconfigure(0, weight=1)
sel_btn_frame.grid_columnconfigure(3, weight=1)
sel_start_btn = ttk.Button(sel_btn_frame, style="secondary.Tbutton", text="Step B: Run Upload", command=lambda:selenium_run_threadsafe()) #goes to run selenium_start then to run_upload_elentra_link
sel_stop_btn  = ttk.Button(sel_btn_frame, bootstyle="dark-outline", text="Stop Upload", command=lambda:selenium_stop(), state='normal')
#sel_close_btn = ttk.Button(sel_frame, bootstyle="dark-outline", text="Close Program", width=10, command=root.destroy)
sel_start_btn.grid( row=0, column=1, sticky='ew', **btn_opts)
sel_stop_btn.grid(  row=0, column=2,sticky='ew', **btn_opts)
#sel_close_btn.grid(row=0, column=3, **btn_opts)
global_buttons += [sel_start_btn, sel_stop_btn]

###~~~~ LAMS Formatter TAB  ~~~~###
# --- Grid options for About tab
# Control vars for LAMS Formatter tab

fmt_row = 0  # or some other starting row index

lams_mode_var = tk.StringVar(value="irat")   # "irat" or "ae"
sot_path_var  = tk.StringVar(value="")
output_folder_formattet = os.path.join(script_dir, os.pardir, "3 data", f"LAMS Formatter_{today_2}")
out_dir_var = tk.StringVar(value=output_folder_formattet)
lams_ai_var = tk.BooleanVar(value=True)

ttk.Checkbutton(formatter_frame, bootstyle="info",
                text="Use AI pre-clean (Ollama)", 
                variable=lams_ai_var).grid(row=fmt_row+4, column=1, sticky='w')

fmt_row = 0
fmt_grid = {
    'title':        dict(row=fmt_row+0, column=0, columnspan=3, sticky='w', padx=10, pady=4),
    'mode_lbl':     dict(row=fmt_row+1, column=0, sticky='e', padx=6, pady=6),
    'mode_irat':    dict(row=fmt_row+1, column=1, sticky='w', padx=4, pady=6),
    'mode_ae':      dict(row=fmt_row+1, column=2, sticky='w', padx=4, pady=6),
    'sot_lbl':      dict(row=fmt_row+2, column=0, sticky='e', padx=6, pady=6),
    'sot_entry':    dict(row=fmt_row+2, column=1, sticky='ew', padx=4, pady=6),
    'sot_btn':      dict(row=fmt_row+2, column=2, sticky='ew', padx=4, pady=6),
    'out_lbl':      dict(row=fmt_row+3, column=0, sticky='e', padx=6, pady=6),
    'out_entry':    dict(row=fmt_row+3, column=1, sticky='ew', padx=4, pady=6),
    'out_btn':      dict(row=fmt_row+3, column=2, sticky='ew', padx=4, pady=6),
    'run_btn':      dict(row=fmt_row+5, column=1, sticky='ew', padx=4, pady=16),
}
formatter_frame.grid_columnconfigure(1, weight=1)

tk.Label(formatter_frame, text="Convert Source-of-Truth (.docx) ➜ LAMS iRAT / AE template",
         font=("Helvetica", 14, "bold")).grid(**fmt_grid['title'])

tk.Label(formatter_frame, text="Mode:").grid(**fmt_grid['mode_lbl'])
ttk.Radiobutton(formatter_frame, bootstyle="info", text="iRAT",
                variable=lams_mode_var, value="irat").grid(**fmt_grid['mode_irat'])
ttk.Radiobutton(formatter_frame, bootstyle="info", text="AE",
                variable=lams_mode_var, value="ae").grid(**fmt_grid['mode_ae'])

tk.Label(formatter_frame, text="SoT .docx:").grid(**fmt_grid['sot_lbl'])
tk.Entry(formatter_frame, textvariable=sot_path_var).grid(**fmt_grid['sot_entry'])
ttk.Button(formatter_frame, style="secondary.Tbutton", text="Browse",
           command=lambda: browse_sot_docx(sot_path_var)).grid(**fmt_grid['sot_btn'])

tk.Label(formatter_frame, text="Output folder:").grid(**fmt_grid['out_lbl'])
tk.Entry(formatter_frame, textvariable=out_dir_var).grid(**fmt_grid['out_entry'])
ttk.Button(formatter_frame, style="secondary.Tbutton", text="Browse",
           command=lambda: select_folder(out_dir_var)).grid(**fmt_grid['out_btn'])

fmt_run_btn = ttk.Button(formatter_frame, style="secondary.Tbutton",
                         text="Run Conversion", command=lambda: formatter_run_threadsafe())
fmt_run_btn.grid(**fmt_grid['run_btn'])
global_buttons += [fmt_run_btn]

###~~~~ GUI LAMS Formatter TAB ~~~~###

def browse_sot_docx(var):
    fp = filedialog.askopenfilename(title="Select SoT .docx",
                                    filetypes=[("Word DOCX", "*.docx")])
    if fp: var.set(fp)



###~~~~ About TAB  ~~~~###
# --- Grid options for About tab
about_row_int = 0
about_grid_opts = {
    'title_label':          dict(row=excel_row_int+0, column=0, columnspan=3, padx=10, pady=4, sticky='w'),
    'about_label':          dict(row=excel_row_int+1, column=0, columnspan=3, padx=10, pady=4, sticky='w'),
}

###~~~~ GUI ABOUT TAB ~~~~###
tk.Label(about_frame, text="Presented by LKCMed Digital Learning ", font=("Helvetic",14,"bold")).grid(**about_grid_opts['title_label'])
tk.Label(about_frame, text="Author: Nelton").grid(**about_grid_opts['about_label'])


# ---- UI Global Log Universal log panel at bottom ----
log_widget = ScrolledText(root, wrap="word", height=15, state="disabled")
log_widget.grid(row=5, column=0, columnspan=3, sticky="s", padx=4, pady=4)
#log_widget.insert('Waiting for next instructions...')
root.grid_rowconfigure(5, weight=1)
#for col in (0, 1, 2):
#    root.grid_columnconfigure(col, weight=1)

# ---- Helper: disable/enable tabs/buttons ----
def set_controls(enabled: bool):
    state = "normal" if enabled else "disabled"
    for btn in global_buttons:
        btn.config(state=state)
    if enabled:
        notebook.tab(0, state="normal"); notebook.tab(1, state="normal"); notebook.tab(2, state="normal")
    else:
        notebook.tab(0, state="disabled"); notebook.tab(1, state="disabled"); notebook.tab(2, state="disabled")
    root.update_idletasks()

# ---- Def LAMS Formatter Tab Logic ----



# ================= LAMS FORMATTER CORE =================

import json, re, requests

def ai_precise_json_from_docx_text(raw_text: str, mode: str, model="qwen3:latest", timeout=90, max_chars=80_000):
    if mode not in ("irat","ae"):
        raise ValueError("mode must be 'irat' or 'ae'")

    def chunk_text(s, limit=max_chars):
        # split on blank-line boundaries near the limit so we don't cut a question in half
        if len(s) <= limit: 
            return [s]
        chunks, start = [], 0
        while start < len(s):
            end = min(len(s), start + limit)
            # backtrack to a double newline if possible
            cut = s.rfind("\n\n", start, end)
            if cut == -1 or cut <= start + 1000:  # don't backtrack too far; just cut
                cut = end
            chunks.append(s[start:cut])
            start = cut
        return chunks

    system = (
        "You are a strict JSON generator for assessment items. "
        "Never include prose, code-fences, or explanations. Output ONLY valid JSON."
    )
    if mode == "irat":
        mark_hint  = "Single-best-answer (A–E)."
        answer_fmt = "Answer MUST be ONE letter a–e (lower-case), mapping options[0]=a, options[1]=b, etc."
    else:
        mark_hint  = "May be single or multi-select."
        answer_fmt = "Answer MUST be letters a–e (lower-case) separated by commas without spaces (e.g. 'b' or 'b,c')."

    def make_prompt(text_block: str) -> str:
        return f"""
Extract questions from the following Source-of-Truth. Normalize them into this schema.

RULES:
- Return ONLY a JSON array (no markdown, no comments).
- Each item has: qnum (integer), stem (string), options (array of strings), answer (string).
- options must be the visible choices in order; strip labels like "(A)", "A)", "A." from the option text.
- {answer_fmt}
- {mark_hint}
- Remove headers/footers/copyright/version lines.
- Map any "Correct Response:" or "Answer:" to 'answer' using the letter scheme above.
- If options are split across lines (e.g., "(A)" then text lines), join into a single option string.
- Keep newlines in 'stem' when helpful.
- Do NOT hallucinate; if unsure, infer best-effort but ALWAYS produce valid schema.

SOURCE:
{text_block}
""".strip()

    def parse_json_text(txt: str):
        txt = re.sub(r"<think>[\s\S]*?</think>", "", txt, flags=re.IGNORECASE).strip()
        try:
            return json.loads(txt)
        except Exception:
            # strip code fences if any
            s = re.sub(r"^```(?:json)?\s*|\s*```$", "", txt, flags=re.IGNORECASE|re.MULTILINE).strip()
            return json.loads(s)

    def validate_and_normalize(arr):
        good = []
        for obj in arr if isinstance(arr, list) else []:
            if not isinstance(obj, dict): 
                continue
            qn   = obj.get("qnum")
            stem = obj.get("stem","")
            opts = obj.get("options",[])
            ans  = obj.get("answer","")
            if not isinstance(qn, int):                continue
            if not isinstance(stem, str):              continue
            if not (isinstance(opts, list) and all(isinstance(x, str) for x in opts) and len(opts) >= 2):
                continue
            if not isinstance(ans, str):               continue

            # strip option labels like "(A) ", "A) ", "A. "
            def _strip_label(s):
                s = s.strip()
                s = re.sub(r"^\(?[A-Ea-e]\)?[.)]\s*", "", s)
                return s.strip()
            opts = [_strip_label(x) for x in opts]
            obj["options"] = opts

            # normalize answers
            letters = "".join(ch for ch in ans.lower() if ch in "abcde,")
            if mode == "irat":
                if len(letters) != 1 or letters not in "abcde":
                    continue
            else:
                parts = [p for p in letters.split(",") if p]
                if not parts or any(len(p)!=1 or p not in "abcde" for p in parts):
                    continue
                letters = ",".join(dict.fromkeys(parts))
            obj["answer"] = letters
            good.append(obj)
        return good

    def post_generate(prompt_text, allow_simple=False):
        url = "http://127.0.0.1:11434/api/generate"
        # Attempt A: full features
        body = {
            "model": model,
            "system": system,
            "prompt": prompt_text,
            "format": "json",
            "raw": True,
            "options": {"temperature": 0},
            "stream": False
        }
        r = requests.post(url, json=body, timeout=timeout)
        if r.status_code == 400 or (r.ok and not r.json().get("response")):
            # Attempt B: inline system, remove 'raw'
            body2 = {
                "model": model,
                "prompt": f"{system}\n\n{prompt_text}",
                "format": "json",
                "options": {"temperature": 0},
                "stream": False
            }
            r = requests.post(url, json=body2, timeout=timeout)
        r.raise_for_status()
        return r.json().get("response","")

    def post_chat(prompt_text):
        url = "http://127.0.0.1:11434/api/chat"
        body = {
            "model": model,
            "messages": [
                {"role":"system","content":system},
                {"role":"user","content":prompt_text}
            ],
            "format": "json",
            "options": {"temperature": 0},
            "stream": False
        }
        r = requests.post(url, json=body, timeout=timeout)
        r.raise_for_status()
        data = r.json()
        if isinstance(data.get("message"), dict):
            return data["message"].get("content","")
        return data.get("response","")

    all_items = []
    for idx, block in enumerate(chunk_text(raw_text)):
        prompt_block = make_prompt(block)
        text = ""
        try:
            text = post_generate(prompt_block)
            if not text.strip():
                # final fallback → chat
                text = post_chat(prompt_block)
        except requests.HTTPError as e:
            # if /generate failed entirely, try chat
            text = post_chat(prompt_block)

        if not text.strip():
            # empty → skip block gracefully
            continue

        try:
            arr  = parse_json_text(text)
            good = validate_and_normalize(arr)
            all_items.extend(good)
        except Exception as ex:
            # skip this chunk but keep processing others
            continue

    if not all_items:
        raise ValueError("AI returned empty response.")
    return all_items


def read_docx_as_text(path: str) -> str:
    """
    Simple utility: load a .docx file and return its text joined by newlines.
    """
    doc = Document(path)
    lines = []
    for p in doc.paragraphs:
        txt = p.text.strip()
        if txt:
            lines.append(txt)
    return "\n".join(lines)

def _norm(s: str) -> str:
    if s is None: return ""
    s = unicodedata.normalize("NFKC", s)
    s = s.replace("\u00A0", " ")
    s = re.sub(r"[ \t]+", " ", s)
    s = re.sub(r"\r\n|\r", "\n", s).strip()
    return s

def _compress_blank(lines, keep=2):
    out, k = [], 0
    for ln in lines:
        if ln.strip()=="":
            k+=1; 
            if k<=keep: out.append("")
        else:
            k=0; out.append(ln)
    return out

# --- drop-in replacement: namespace-free image extractor ---
def _extract_inline_images(doc: Document):
    """
    Returns {paragraph_index: [bytes, ...]} mapping for inline images.
    Does NOT use xpath(namespaces=...) so it works across python-docx versions.
    """
    mapping = {}
    for p_idx, p in enumerate(doc.paragraphs):
        for run in p.runs:
            r = run._element
            # Walk the XML tree; look for any blip elements (<a:blip>)
            for el in r.iter():
                # el.tag is like '{namespace}blip' -> check localname
                if el.tag and el.tag.endswith('}blip'):
                    # r:embed attribute holds the relationship id to the image
                    rid = el.get(qn('r:embed'))
                    if not rid:
                        continue
                    try:
                        part = doc.part.related_parts[rid]
                        blob = part.blob
                        mapping.setdefault(p_idx, []).append(blob)
                    except KeyError:
                        # relationship not found; ignore
                        pass
    return mapping


def _insert_images(doc: Document, blobs: list, max_width_in=5.5):
    for b in blobs or []:
        try:
            img = Image.open(io.BytesIO(b))
            doc.add_picture(io.BytesIO(b), width=Inches(max_width_in))
        except Exception:
            try:
                doc.add_picture(io.BytesIO(b), width=Inches(max_width_in))
            except Exception:
                pass

# --- iRAT PARSER (tolerant) ---
_RE_QID_WORD   = re.compile(r"^\s*QUESTIONS?\s+(\d+)\s*:?\s*$", re.I)   # QUESTION 1 / Questions 1:
_RE_QID_QUESTION = re.compile(r"^\s*Question\s+(\d+)\s*:?\s*$", re.I)   # Question 1:
_RE_QID_NUMDOT = re.compile(r"^\s*(\d+)\.\s*(.*)$")                     # 1. Stem...
_RE_OPT        = re.compile(r"^\s*[\(\[]?([A-Ea-e])[\)\].]?\s*(.*)$")
_RE_ANS_COL    = re.compile(r"^\s*Answer\s*[:]\s*(.+?)\s*$", re.I)

# --- iRAT PARSER (robust for "(A)\\n<text>" patterns and "Correct Response:") ---
_RE_Q_COLON    = re.compile(r"^\s*Question\s+(\d+)\s*:\s*$", re.I)   # Question 1:
_RE_OPT_LINE   = re.compile(r"^\s*\(?([A-Ea-e])\)?\s*$")             # (A)  OR  A  on its own line
_RE_OPT_INLINE = re.compile(r"^\s*\(?([A-Ea-e])\)?[.)]\s+(.*)$")     # A) text   or  (A) text
_RE_ANS_CORR   = re.compile(r"^\s*Correct\s+Response\s*:\s*([A-Ea-e])\s*$", re.I)
_RE_ANS_COL    = re.compile(r"^\s*Answer\s*:\s*([A-Ea-e](?:\s*,\s*[A-Ea-e])*)\s*$", re.I)

def parse_irat_docx(docx_path: str):
    doc = Document(docx_path)
    lines = [_norm(p.text) for p in doc.paragraphs]
    lines = _compress_blank(lines)

    # image anchoring (coarse)
    img_map = _extract_inline_images(doc)
    par_to_imgs = {}
    for p_idx, blobs in img_map.items():
        anchor = min(p_idx, len(lines)-1)
        while anchor > 0 and lines[anchor].strip() == "":
            anchor -= 1
        par_to_imgs.setdefault(anchor, []).extend(blobs)

    items = []
    i = 0
    while i < len(lines):
        m_q = _RE_Q_COLON.match(lines[i])
        if not m_q:
            i += 1
            continue

        qnum = int(m_q.group(1))
        i += 1

        # 1) collect stem until first option marker or answer/next question
        stem_lines = []
        while i < len(lines):
            ln = lines[i]
            if _RE_OPT_LINE.match(ln) or _RE_OPT_INLINE.match(ln) or _RE_ANS_CORR.match(ln) or _RE_ANS_COL.match(ln) or _RE_Q_COLON.match(ln):
                break
            if ln.strip():
                stem_lines.append(ln)
            i += 1

        # 2) collect options
        options = []
        current_opt_text = None

        def flush_opt():
            nonlocal current_opt_text
            if current_opt_text is not None:
                options.append(current_opt_text.strip())
                current_opt_text = None

        while i < len(lines):
            ln = lines[i]
            # stop if we hit answer or next question
            if _RE_ANS_CORR.match(ln) or _RE_ANS_COL.match(ln) or _RE_Q_COLON.match(ln):
                flush_opt()
                break

            m_inline = _RE_OPT_INLINE.match(ln)
            m_line   = _RE_OPT_LINE.match(ln)

            if m_inline:
                # e.g. "A) some text"
                flush_opt()
                current_opt_text = m_inline.group(2).strip()
                i += 1
                # gather continuation lines until next marker/answer/question/blank-blank
                while i < len(lines):
                    nx = lines[i]
                    if _RE_OPT_LINE.match(nx) or _RE_OPT_INLINE.match(nx) or _RE_ANS_CORR.match(nx) or _RE_ANS_COL.match(nx) or _RE_Q_COLON.match(nx):
                        break
                    if nx.strip():
                        current_opt_text += "\n" + nx
                    i += 1
                continue

            if m_line:
                # e.g. "(A)" then next non-empty lines are the text until the next marker
                flush_opt()
                i += 1
                # next lines form the option text block
                block = []
                while i < len(lines):
                    nx = lines[i]
                    if _RE_OPT_LINE.match(nx) or _RE_OPT_INLINE.match(nx) or _RE_ANS_CORR.match(nx) or _RE_ANS_COL.match(nx) or _RE_Q_COLON.match(nx):
                        break
                    if nx.strip():
                        block.append(nx)
                    i += 1
                current_opt_text = "\n".join(block).strip()
                flush_opt()
                continue

            # if a random line between options (e.g. stray blank), just move on
            i += 1

        # 3) answer (Correct Response: X preferred; Answer: X fallback)
        ans = ""
        if i < len(lines) and (_RE_ANS_CORR.match(lines[i]) or _RE_ANS_COL.match(lines[i])):
            m_corr = _RE_ANS_CORR.match(lines[i])
            if m_corr:
                ans = m_corr.group(1).lower()
            else:
                m_col = _RE_ANS_COL.match(lines[i])
                if m_col:
                    letters = re.findall(r"[A-Ea-e]", m_col.group(1))
                    ans = ",".join([c.lower() for c in letters])
            i += 1  # consume the answer line

        items.append({
            "mode": "irat",
            "qnum": qnum,
            "stem": "\n".join(stem_lines).strip(),
            "options": options,
            "answer": ans,
            "images": par_to_imgs
        })

    return items

# ---------- AE PARSER ----------
_RE_CASE     = re.compile(r"^\s*Case\s+\d+\s*:\s*$", re.I)
_RE_Q_AE     = re.compile(r"^\s*(?:(\d+)\.|([Aa]\d+)\.)\s+(.+)$")
_RE_ANS_DASH = re.compile(r"^\s*Answer\s*[-–:]\s*(.+?)\s*$", re.I)
_RE_RAT      = re.compile(r"^\s*Rationale\s*[-–:]\s*(.+?)\s*$", re.I)
_RE_Q_AE_CAPS = re.compile(r"^\s*QUESTION\s+(\d+)\s*$", re.I)

def parse_ae_docx(docx_path: str):
    doc = Document(docx_path)
    raw = [_norm(p.text) for p in doc.paragraphs]
    lines = _compress_blank(raw)

    img_map = _extract_inline_images(doc)
    par_to_imgs = {}
    for p_idx, blobs in img_map.items():
        anchor = p_idx
        while anchor>0 and (anchor>=len(lines) or lines[anchor].strip()==""):
            anchor -= 1
        par_to_imgs.setdefault(anchor, []).extend(blobs)

    res = []
    cur_case = []
    i = 0; qn = 0
    while i < len(lines):
        if _RE_CASE.match(lines[i]):
            case_block = [lines[i]]; i += 1
            while i < len(lines) and not _RE_CASE.match(lines[i]) and not _RE_Q_AE.match(lines[i]):
                case_block.append(lines[i]); i += 1
            cur_case = [x for x in case_block if x.strip()]
            continue

        m_caps = _RE_Q_AE_CAPS.match(lines[i])
        if m_caps:
            qn += 1
            stem_first = ""
            i += 1
            collected = []
            while i < len(lines) and not _RE_Q_AE.match(lines[i]) and not _RE_CASE.match(lines[i]):
                collected.append(lines[i]); i += 1

            # split options / answer
            ans = ""
            options = []
            a_idx = next((k for k,L in enumerate(collected) if _RE_ANS_DASH.match(L)), None)
            if a_idx is not None:
                opt_block = collected[:a_idx]
                raw = _RE_ANS_DASH.match(collected[a_idx]).group(1)
                letters = re.findall(r"[A-Ea-e]", raw)
                ans = ",".join([c.lower() for c in letters])
            else:
                opt_block = collected

            options = [x.strip() for x in opt_block if x.strip()]

            res.append({
                "mode": "ae",
                "qnum": qn,
                "case": [*cur_case],
                "stem": stem_first,
                "options": options,
                "answer": ans,
                "images": par_to_imgs
            })
            continue
        i += 1
    return res

# ---------- RENDER & REPORT ----------
def _setup_doc(doc: Document):
    style = doc.styles['Normal']
    style.font.name = 'Calibri'
    style._element.rPr.rFonts.set(qn('w:eastAsia'), 'Calibri')
    style.font.size = Pt(11)

def render_irat_doc(items, out_docx, mark_value="1"):
    doc = Document(); _setup_doc(doc)
    labels = ["A","B","C","D","E","F"]

    for it in items:
        p = doc.add_paragraph(); p.add_run("Question: ").bold = True
        doc.add_paragraph(it.get("stem",""))

        # images (coarse heuristic: insert once under stem if any found)
        imgs = []
        for v in (it.get("images") or {}).values():
            imgs.extend(v)
        if imgs:
            _insert_images(doc, imgs)

        for idx, opt in enumerate(it.get("options", [])):
            doc.add_paragraph(labels[idx] if idx<len(labels) else chr(65+idx))
            doc.add_paragraph(opt)

        ap = doc.add_paragraph(); ap.add_run("\nAnswer: ").bold = True
        ap.add_run(it.get("answer",""))

        mp = doc.add_paragraph(); mp.add_run("\nMark: ").bold = True
        mp.add_run(mark_value)  # iRAT default 1

        fp = doc.add_paragraph(); fp.add_run("\nFeedback: ").bold = True
        lp = doc.add_paragraph(); lp.add_run("\nLO: ").bold = True

        doc.add_paragraph("\n")
    doc.save(out_docx)

def render_ae_doc(items, out_docx, mark_value="4"):
    doc = Document(); _setup_doc(doc)

    for it in items:
        qn = it["qnum"]
        p = doc.add_paragraph(); p.add_run("Question: ").bold = True
        p.add_run(f"Question {qn}")

        for line in it.get("case", []):
            if line.strip(): doc.add_paragraph(line)

        # images under case/stem
        imgs = []
        for v in (it.get("images") or {}).values():
            imgs.extend(v)
        if imgs:
            _insert_images(doc, imgs)

        sp = doc.add_paragraph(); sp.add_run(f"\nQUESTION {qn}\n").bold = True
        if it.get("stem"): doc.add_paragraph(it["stem"])
        for opt in it.get("options", []):
            doc.add_paragraph(opt)

        ap = doc.add_paragraph(); ap.add_run("\nAnswer: ").bold = True
        ap.add_run(it.get("answer",""))

        mp = doc.add_paragraph(); mp.add_run("\nMark: ").bold = True
        mp.add_run(mark_value)  # AE default 4

        fp = doc.add_paragraph(); fp.add_run("\nFeedback: ").bold = True
        lp = doc.add_paragraph(); lp.add_run("\nLO: ").bold = True

        doc.add_paragraph("\n")
    doc.save(out_docx)

def qc_rows(items):
    out = []
    for it in items:
        option_count = len(it.get("options", []))
        has_answer = bool(it.get("answer","").strip())
        multi = "," in it.get("answer","")
        flags=[]
        if not it.get("stem","").strip(): flags.append("empty_stem")
        if option_count < 2: flags.append("too_few_options")
        if any(len(o)>240 for o in it.get("options", [])): flags.append("long_option_lines")
        out.append({
            "mode": it["mode"],
            "qnum": it.get("qnum",""),
            "stem_chars": len(it.get("stem","")),
            "option_count": option_count,
            "has_answer": has_answer,
            "multi_select": multi,
            "images_present": bool(it.get("images")),
            "flags": ";".join(flags)
        })
    return out

def write_qc_csv(rows, csv_path):
    with open(csv_path, "w", newline="", encoding="utf-8") as f:
        w = csv.DictWriter(f, fieldnames=list(rows[0].keys()) if rows else
            ["mode","qnum","stem_chars","option_count","has_answer","multi_select","images_present","flags"])
        w.writeheader()
        for r in rows: w.writerow(r)
# ================= END LAMS FORMATTER CORE =================

def formatter_run_threadsafe():
    set_controls(True)
    threading.Thread(target=formatter_run, daemon=True).start()
    notebook.select(formatter_frame)

def parse_generic_qna_docx(docx_path: str):
    """
    Fallback parser for simple 'stem + options + Answer: X' blocks.
    Groups blocks separated by blank lines. Accepts 3–8 options lines.
    """
    doc = Document(docx_path)
    lines = [_norm(p.text) for p in doc.paragraphs]
    lines = _compress_blank(lines, keep=2)

    blocks, buf = [], []
    for ln in lines + [""]:
        if ln.strip():
            buf.append(ln)
        else:
            if buf:
                blocks.append(buf); buf=[]
    items = []
    qn = 0
    for b in blocks:
        # Find "Answer:" line
        ans_idx = next((i for i, t in enumerate(b) if re.match(r"^\s*Answer\s*:\s*([A-Ea-e])", t)), None)
        if ans_idx is None:
            continue
        m = re.match(r"^\s*Answer\s*:\s*([A-Ea-e])", b[ans_idx])
        ans_letter = m.group(1).lower()

        # Before 'Answer:' expect at least 3 consecutive lines that look like options and a preceding stem
        # Heuristic: last 3–8 lines before Answer are options (short-ish lines); everything before them is stem
        pre = b[:ans_idx]
        if len(pre) < 4:
            continue
        # take tail lines until we hit a long blank or capitalized heading; simpler: assume 3–8 options
        # choose the longest suffix 3..8 whose lines are not empty
        opt = None
        for k in range(8, 2, -1):
            if len(pre) >= k:
                tail = pre[-k:]
                if all(t.strip() for t in tail):
                    opt = tail; break
        if not opt: 
            continue
        stem_lines = pre[:-len(opt)]
        if not stem_lines:
            continue

        qn += 1
        items.append({
            "mode": "irat",                  # or “ae”: we’ll keep whatever mode user selected later
            "qnum": qn,
            "stem": "\n".join(stem_lines).strip(),
            "options": [t.strip() for t in opt],
            "answer": ans_letter,
            "images": {}
        })
    return items


def formatter_run():
    try:
        mode = lams_mode_var.get().strip()      # "irat" or "ae"
        sot  = sot_path_var.get().strip()
        outd = out_dir_var.get().strip()
        use_ai = lams_ai_var.get()

        if mode not in ("irat","ae"):
            log("❌ Please pick mode: iRAT or AE"); return
        if not sot or not os.path.isfile(sot) or not sot.lower().endswith(".docx"):
            log("❌ Please pick a valid SoT .docx file"); return
        if not outd:
            log("❌ Please choose an output folder"); return
        Path(outd).mkdir(parents=True, exist_ok=True)

        ts = datetime.now().strftime("%y%m%d_%H%M%S")
        base = Path(sot).stem
        out_docx = str(Path(outd) / f"{base}_{mode}_{ts}.docx")
        out_csv  = str(Path(outd) / f"{base}_{mode}_{ts}_qc.csv")

        if use_ai:
            log("🤖 Using AI pre-clean (Ollama)…")
            raw = read_docx_as_text(sot)
            try:
                ai_objs = ai_precise_json_from_docx_text(raw, mode)
                items = items_from_ai_json(ai_objs, mode)
            except Exception as e:
                log(f"⚠️ AI pre-clean failed: {e}")
                log("↩️ Falling back to deterministic parser…")
                use_ai = False  # fall through to classic path

        if not use_ai:
            if mode == "irat":
                items = parse_irat_docx(sot)
                if not items:
                    # NEW: try generic parser
                    items = parse_generic_qna_docx(sot)
                if not items:
                    log("❌ No questions detected with deterministic iRAT parser."); return
            else:
                items = parse_ae_docx(sot)
                if not items:
                    # NEW: AE can reuse the generic parser too; it will still produce items
                    items = parse_generic_qna_docx(sot)
                    # mark mode so downstream rendering uses AE layout if desired
                    for it in items: it["mode"] = "ae"
                if not items:
                    log("❌ No questions detected with deterministic AE parser."); return


        # Render + CSV (same as before)
        if mode == "irat":
            render_irat_doc(items, out_docx, mark_value="1")
        else:
            render_ae_doc(items, out_docx, mark_value="4")

        rows = qc_rows(items)
        write_qc_csv(rows, out_csv)

        log("✅ Done.")
        log(f"📄 DOCX : {out_docx}")
        log(f"📊 CSV  : {out_csv}")

    except Exception as e:
        log(f"❌ Formatter error: {e}")
    finally:
        set_controls(True)


# ---- Def Excel Tab Logic ----

def select_folder(var):
    folder = filedialog.askdirectory(initialdir=var.get())
    if folder: var.set(folder)

def excel_run_threadsafe():
    set_controls(True)
    threading.Thread(target=excel_run, daemon=True).start()
    notebook.select(excel_frame)

def excel_run():
    try:
        cid_raw = course_id_text.get('1.0', 'end').strip()
        add_info_raw = add_info_text.get('1.0', 'end').strip()
        role     = role_entry.get().strip()
        folder  = save_dir_var.get().strip()
        os.makedirs(folder, exist_ok=True)
        mode    = mode_var.get()
        emails  = parse_emails(email_text.get('1.0', 'end'))
    
        if not os.path.isdir(folder):
            log("❌ Could not create Save Folder.")
            return

        if mode == 'student':
            name = course_name_entry.get().strip()
            # also require a role and some additional info
            if not (emails and cid_raw and name and role and add_info_raw):
                log("❌ Please fill Course Name, Course ID, Role, Emails AND Additional Info."); 
                return
            # pass role + add_info_raw into build_student_file
            if len(cid_raw.split()) > 1 or len(add_info_raw.split()) > 1:
                log("❌ Course IDs or Additional Info are limited to one entry!")
                return
            
            path = build_student_file(folder, name, cid_raw, emails, role, add_info_raw)
            log(f"✅ Student file generated:\n{path}")
        
        else: #staff
            dept     = dept_entry.get().strip()

            # parse on both lines and commas
            course_ids = [
                part.strip()
                for line in cid_raw.splitlines()
                for part in line.split(',')
                if part.strip()
            ]

            add_infos = [
                part.strip()
                for line in add_info_raw.splitlines()
                for part in line.split(',')
                if part.strip()
            ]
            
            if len(add_infos) != len(course_ids):
                log("❌ You must supply exactly one Additional-Info entry per Course ID.")
                return
            
            # 5) other validations
            if not (emails and course_ids and dept and role):
                log("❌ Please fill Department, Course IDs, Role, and Emails.")
                return

            files = build_staff_files(
                folder,
                dept,
                course_ids,
                emails,
                role,
                add_infos
            )
            log(f"✅ {len(files)} staff files generated:\n" + "\n".join(files))

    finally:
        set_controls(True)
    notebook.select(excel_frame) # switch back to Excel tab

def switch_mode():
    mode = mode_var.get()
    if mode == 'student':
        header_var.set(' | '.join(STUDENT_HEADERS))
        course_name_entry.config(state='normal')
        dept_entry.config(state='disabled')
        role_entry.delete(0, 'end'); role_entry.insert(0, 'learner')
        course_id_text.delete('1.0', 'end'); course_id_text.insert('1.0', "629")
        add_info_text.delete('1.0', 'end'); add_info_text.insert('1.0', "Course_1")

    else: #staff
        header_var.set(' | '.join(STAFF_HEADERS))
        course_name_entry.config(state='disabled')
        dept_entry.config(state='normal')
        role_entry.delete(0, 'end'); role_entry.insert(0, 'monitor')
        course_id_text.delete('1.0', 'end'); course_id_text.insert('1.0', sample_course_id_text)
        add_info_text.delete('1.0', 'end'); add_info_text.insert('1.0', sample_course_name_text)

# ---- Def Combine Tab Logic ----
def combine_all_threadsafe():
    set_controls(True)
    threading.Thread(target=combine_all, daemon=True).start()
    notebook.select(combine_frame)

# --- make the ScrolledText a real widget, not None ---
to_combine_box = ScrolledText(
    combine_frame,
    wrap="word",
    width=45,
    height=15,
    state="disabled"
)
to_combine_box.grid(**combine_grid_opts['to_combine_log_box'])

def scan_files_to_combine():
    # Disable all controls while we browse+scan
    set_controls(True)

    # 1) Ask the user to pick a folder, defaulting to the last one
    folder = filedialog.askdirectory(
        title="Select folder containing .xls files",
        initialdir=combine_dir_var.get() or None
    )
    if not folder:
        # User cancelled; re-enable controls and bail
        set_controls(True)
        return

    # 2) Remember their choice
    combine_dir_var.set(folder)
    folder_path = Path(folder)

    # 3) Prepare the log box
    to_combine_box.config(state="normal")
    to_combine_box.delete("1.0", "end")

    # 4) Scan & report
    if not folder_path.is_dir():
        to_combine_box.insert("end", f"❌ Invalid folder:\n    {folder_path}\n")
    else:
        xls_files = sorted(folder_path.glob("*.xls"))
        to_combine_box.insert("end", f"📂 Scanning: {folder_path}\n")
        to_combine_box.insert("end", f"🔢 {len(xls_files)} file(s) found:\n")
        if xls_files:
            for f in xls_files:
                to_combine_box.insert("end", f"  • {f.name}\n")
        else:
            to_combine_box.insert("end", "  (no .xls files in this folder)\n")

    # 5) Scroll to the bottom, lock the log, re-enable controls
    to_combine_box.see("end")
    to_combine_box.config(state="disabled")
    set_controls(True)
    notebook.select(combine_frame)

def combine_xls_pyexcel(date_str: str, output_basename: str, folder: Path) -> Path:
    # make sure the .xls plugin is available
    try:
        import pyexcel_xls  # noqa: F401
    except ImportError:
        raise RuntimeError(
            "Please install pyexcel-xls (pip install pyexcel-xls) to get .xls support."
        )

    files = sorted(folder.glob("*.xls"))
    if not files:
        raise FileNotFoundError(f"No .xls files found in {folder}")

    all_rows = []
    header = None

    for f in files:
        sheet = pyexcel.get_sheet(file_name=str(f), name_columns_by_row=0)
        rows = sheet.to_array()
        if not rows:
            continue
        if header is None:
            header = rows[0]
            all_rows.append(header)
        all_rows.extend(rows[1:])

    out_dir = folder / "output"
    out_dir.mkdir(exist_ok=True)

    # build a filename like "myfolder_combined_210101_235959.xls"
    safe_name = Path(output_basename).stem
    timestamp = date_str
    out_file = f"{safe_name}_{timestamp}.xls"
    out_path = out_dir / out_file

    pyexcel.save_as(array=all_rows, dest_file_name=str(out_path))
    return out_path

def combine_all():
    folder = Path(combine_dir_var.get().strip())
    if not folder.is_dir():
        log("❌ Please select a valid folder to combine from.")
        set_controls(True)
        return

    folder_name = folder.name
    date_str = datetime.now().strftime("%y%m%d_%H%M%S")
    output_basename = f"{folder_name}_combined"

    try:
        new_file = combine_xls_pyexcel(date_str, output_basename, folder)
        log(f"✅ Combined .xls created:\n   {new_file}")
    except Exception as e:
        log(f"❌ Failed to combine: {e}")
    finally:
        set_controls(True)
    notebook.select(combine_frame) # switch back to Combine tab
    

# ---- Def Selenium Tab Logic ----
selenium_abort = tk.BooleanVar(value=False)

sel_controls = [
    Elentra_Event_label, LAMS_Lesson_ID_label, LAMS_Lesson_Title_label,
    Upload_Monitor_URL_icon, Upload_Student_URL_icon]

global w

def set_selenium_controls(state: str):
    for w in sel_controls:
        w.config(state=state)

def selenium_run_threadsafe():
    set_controls(True)
    notebook.select(selenium_frame)

    # disable start, enable stop
    sel_start_btn.config(state="disabled")
    sel_stop_btn.config(state="normal")

    # clear your abort flag
    selenium_abort.set(False)

    # disable all the inputs too
    set_selenium_controls("disabled")

    threading.Thread(target=selenium_start, daemon=True).start()
    #threading.Thread(target=selenium_test, daemon=True).start()
    selenium_frame.tkraise()

def selenium_test():
    # Insert your entire Selenium RPA workflow here (from code #1)
    try:
        log("🚦 Selenium RPA started…")
        # Example: for demonstration, just sleep

        for i in range(10):
            if selenium_abort.get():
                log(f"🛑 Selenium stopped by user after step {i+1}.")
                break
            log(f"Step {i+1}/10…")
            time.sleep(0.1)
        
        log("🎉 Selenium workflow done!")
        
    except Exception as e:
        log(f"❌ Selenium error: {e}")

    finally:
        set_controls(True)

time_sleep = 0.5 #1 sec or 0.5 sec # wait x seconds between actions, for presentation purposes
time_out = 10 #wait up to x seconds for element to be clickable
highlight_duration = 0.05 #set in def highlight ()

# function for left to right typing animation
def dramatic_input(element, text, delay=0.5):
    """Type each character with a small pause to mimic a human."""
    for ch in text:
        element.send_keys(ch)
        # time.sleep(delay)

# function for highlight element in red, for presentation purposes 1 sec or 0.1 sec, value to be lower than time_sleep
def highlight(el, duration = highlight_duration, color='clear', border="4px solid red"):
    # 1) Scroll the element into view
    driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", el)
    # 2) Save its current style so we can restore later
    original_style = el.get_attribute("style") or ""
    # 3) Overwrite with our highlight style
    highlight_style = f"background: {color} !important; border: {border} !important; {original_style}"
    driver.execute_script("arguments[0].setAttribute('style', arguments[1]);", el, highlight_style)
    # 4) Pause so you can actually *see* it
    time.sleep(highlight_duration) #declared in main
    # 5) Restore original style
    driver.execute_script("arguments[0].setAttribute('style', arguments[1]);", el, original_style)

# function for Wait until clickable
def wait_and_click(driver, xpath, timeout, highlight_fn, message, sleep_after):
    """
    Wait up to `timeout` seconds for an element to be clickable, highlight it, click it, print `message`, sleep, and return the element.
    If it never becomes clickable, logs an error and re-raises.
    """
    global log_var, root
    try:
        el = WebDriverWait(driver, timeout).until(
            EC.element_to_be_clickable((By.XPATH, xpath))
        )
        if highlight_fn:
            highlight_fn(el)
        el.click()
        if message:
            log(message)
            root.update() #better root.update_idletasks()
            
        if sleep_after:
            time.sleep(sleep_after) # time sleep declared in main
        return el

    except TimeoutException:
        print("❌ Element never became clickable: %s", xpath)
        log.error("Element never became clickable: %s", xpath) # re-raise so outer code can catch it if desired
        raise

#main function
def run_upload_elentra_link(Elentra_Event_entry, LAMS_Lesson_ID_entry, LAMS_Lesson_Title_entry, Upload_Monitor_URL_checkbox, Upload_Student_URL_checkbox):
    start_time = time.time()  
     
    # 1) Request for inputs 
    elentra_event_id   = Elentra_Event_entry
    elentra_event_name = None
    lams_lesson_id     = LAMS_Lesson_ID_entry
    lams_lesson_title  = LAMS_Lesson_Title_entry
    use_monitor        = Upload_Monitor_URL_checkbox
    use_student        = Upload_Student_URL_checkbox

    #print("Choices:", elentra_event_id, lams_lesson_id,lams_lesson_title, use_monitor, use_student)
    print("✅ ID input")
    log("✅ ID input")

    # 2) Build URLs & Title
    elentra_event_url   = f"https://ntu.elentra.cloud/events?id={elentra_event_id}"
    #elentra_event_name = f"Elentra {elentra_event_id}"
    lams_monitor_title = f"LAMS {lams_lesson_title} (Facilitator/CE)"
    lams_monitor_url   = f"https://ilams.lamsinternational.com/lams/monitoring/monitoring/monitorLesson.do?lessonID={lams_lesson_id}"
    lams_student_title = f"LAMS {lams_lesson_title}"
    lams_student_url   = f"https://ilams.lamsinternational.com/lams/home/learner.do?lessonID={lams_lesson_id}"
    print("✅ URL input")
    log("✅ URL input")
    
    # 3) Setup Chrome WebDriver to attach to existing debug session
    #macos-----
    # chrome_driver_path = "/Users/neltontan/Driver/chromedriver-mac-arm64/chromedriver"
    #windows-----
    chrome_driver_path = r"C:\WebDrivers\chromedriver-win64\chromedriver.exe"

    global driver
    service = Service(executable_path=chrome_driver_path)
    options = Options()
    options.add_experimental_option("debuggerAddress", "127.0.0.1:9222")
    driver = webdriver.Chrome(service=service, options=options)
    print("✅ Chrome WebDriver started")
    log("✅ Chrome WebDriver started")
    
    try:
        # 4) Navigate to Elentra Event Page
        if True: #to group the lines of code
            driver.get(elentra_event_url)
            print("✅ Navigated to Elentra event page")
            log("✅ Navigated to Elentra event page")
            time.sleep(time_sleep)

        # 5) Administrator checkbox
        wait_and_click(
            driver,
            "/html/body/div[1]/div/div[2]/div[2]/div[3]/div[2]/ul/li[2]/a/span",
            timeout=time_out,
            highlight_fn=highlight,
            message="✅ Administrator checkbox clicked",
            sleep_after=time_sleep
        )

        # 6) Content tab
        wait_and_click(
            driver,
            "/html/body/div[1]/div/div[3]/div/div[2]/ul/li[2]/a",
            timeout=time_out,
            highlight_fn=highlight,
            message="✅ Content link clicked",
            sleep_after=time_sleep
        )

        # event name
        if True: #to group the lines of code
        # a) wait for the H1 to be present
            h1 = WebDriverWait(driver, time_out).until(
                EC.presence_of_element_located((By.XPATH, "/html/body/div[1]/div/div[3]/div/h1[1]"))
            )
            highlight(h1)
            # b) extract its text
            elentra_event_name = h1.text
            print("✅ Page title is:", elentra_event_name)
            log("✅ Page title is: "+ elentra_event_name)

        log("⏳ Inserting MONITOR URL⏳")
        print("⏳ Inserting MONITOR URL⏳")
        if use_monitor:
            # 7) Scroll down page
            if True: #to group the lines of code
                driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                print("✅ Scrolled to bottom")
                log("✅ Scrolled to bottom")
                time.sleep(time_sleep)

            # # 8) No Time Frame
            # wait_and_click(
            #     driver,
            #     "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[3]/ul/li[4]/a",
            #     timeout=time_out,
            #     highlight_fn=highlight,
            #     message="✅ No Time Frame link clicked",
            #     sleep_after=time_sleep
            # )
            
            # 9) Add a Resource
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[3]/div[1]/a",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Add a Resource link clicked",
                sleep_after=time_sleep
            )

            # 10) 'Link' Resource checkbox
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div/label[6]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Link checkbox selected",
                sleep_after=time_sleep
            )

            # 11) Next Step
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[3]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Next Step Button clicked",
                sleep_after=time_sleep
            ) 
            
            #** 12) Optional 
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[1]/label[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Optional selected",
                sleep_after=time_sleep
            )
            
            # 13) No Timeframe
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[2]/label[4]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ No Timeframe link clicked",
                sleep_after=time_sleep
            )
            
            # 14) Next Step
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[3]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Next step (to Hide)",
                sleep_after=time_sleep
            )
            
            # 15) No, this resource is accessible any time
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[1]/label[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ No, this resource is accessible any time selected",
                sleep_after=time_sleep
            )
            
            #** 16) Hide this resource from learners
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[3]/label[2]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Hide this resource from learners selected",
                sleep_after=time_sleep
            )
            
            # 17) Published
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[4]/label[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Published selected",
                sleep_after=time_sleep
            )
            
            # 18) Next Step
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[3]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Final Next Step clicked",
                sleep_after=time_sleep
            )
            
            # 18.5) No, the proxy isnt required to be enabled selected
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[1]/div/label[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ No, the proxy isnt required to be enabled selected",
                sleep_after=time_sleep
            )

            print("⏳ Inserting LAMS title & URL now ⏳")
            log("⏳ Inserting LAMS title & URL now ⏳")
            
            #*** 19) Enter Monitor URL
            if True:
                time.sleep(0.5)
                el = WebDriverWait(driver, time_sleep).until(
                    EC.visibility_of_element_located((By.XPATH,
                        "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[2]/div/input"
                    ))
                )
                highlight(el)
                el.clear()
                el.send_keys(lams_monitor_url)
                #dramatic_input(el, lams_monitor_url)
                print("✅ Monitor URL entered")
                log("✅ Monitor URL entered")
                time.sleep(time_sleep)
            
            #*** 20) Enter Lesson Title
            if True: #to group the lines of code
                el = WebDriverWait(driver, time_sleep).until(
                    EC.visibility_of_element_located((By.XPATH,
                        "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[3]/div/input"
                    ))
                )
                highlight(el)
                el.clear()
                el.send_keys(lams_monitor_title)
                #dramatic_input(el, LAMS_Lesson_Title_2)
                print("✅ Title entered")
                log("✅ Title entered")
                time.sleep(time_sleep)

            #*** 21) Scroll the message box to the bottom
            if True: #to group the lines of code
                modal = WebDriverWait(driver, time_out).until(
                    EC.presence_of_element_located((By.ID, "event-resource-modal"))
                )
                highlight(modal)
                driver.execute_script(
                    "arguments[0].scrollTop = arguments[0].scrollHeight;",
                    modal
                )
                print("✅ Modal scrolled to bottom")
                log("✅ Modal scrolled to bottom")
                time.sleep(time_sleep)
                  
            #*** 22) Enter Description
            time.sleep(0.5)
            if True: #to group the lines of code
                iframe = driver.find_element(
                    By.CSS_SELECTOR,
                    "#cke_event-resource-link-description iframe.cke_wysiwyg_frame"
                )
                driver.switch_to.frame(iframe)
                print("✅ Switched to iframe")
                log("✅ Switched to iframe")

                editor_body = driver.find_element(
                    By.CSS_SELECTOR,
                    "body[contenteditable='true']"
                )
                highlight(editor_body)
                try:
                    editor_body.clear()
                except:
                    editor_body.send_keys(Keys.COMMAND + "a", Keys.DELETE)
                
                editor_body.send_keys(lams_monitor_title)
                #dramatic_input(editor_body, LAMS_Lesson_Title_2)
                driver.switch_to.default_content()
                print("✅ Description added")
                log("✅ Description added")

                time.sleep(time_sleep)

            # 23) Save Resource
            time.sleep(0.5)
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[3]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Resource saved",
                sleep_after=time_sleep
            )

            # 24) Close
            time.sleep(0.5)
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Closed attachment dialog",
                sleep_after=time_sleep,
                
            )
        
        log("⏳ Inserting STUDENT URL⏳")
        print("⏳ Inserting STUDENT URL⏳")
        if use_student:
            # 7) Scroll down page
            if True: #to group the lines of code
                driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                print("✅ Scrolled to bottom")
                log("✅ Scrolled to bottom")
                time.sleep(time_sleep)

            #  Nelton: cuz button grayout, so cannot click 
            # # 8) No Time Frame
            # wait_and_click(
            #     driver,
            #     "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[3]/ul/li[4]/a",
            #     timeout=time_out,
            #     highlight_fn=highlight,
            #     message="✅ No Time Frame link clicked",
            #     sleep_after=time_sleep
            # )

            # 9) Add a Resource
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[3]/div[1]/a",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Add a Resource link clicked",
                sleep_after=time_sleep
            )

            # 10) 'Link' Resource checkbox
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div/label[6]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Link checkbox selected",
                sleep_after=time_sleep
            )

            # 11) Next Step
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[3]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Next Step Button clicked",
                sleep_after=time_sleep
            ) 
            
            #** 12) Required 
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[1]/label[2]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Optional selected",
                sleep_after=time_sleep
            )
            
            # 13) No Timeframe
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[2]/label[4]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ No Timeframe link clicked",
                sleep_after=time_sleep
            )
            
            # 14) Next Step
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[3]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Next step (to Hide)",
                sleep_after=time_sleep
            )
            
            # 15) No, this resource is accessible any time
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[1]/label[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ No, this resource is accessible any time selected",
                sleep_after=time_sleep
            )
            
            #** 16) Hide this resource from learners
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[3]/label[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Allow learners to view this resource selected",
                sleep_after=time_sleep
            )
            
            # 17) Published
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[4]/label[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Published selected",
                sleep_after=time_sleep
            )
            
            # 18) Next Step
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[3]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Final Next Step clicked",
                sleep_after=time_sleep
            )
            
            # 18.5) No, the proxy isnt required to be enabled selected
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[1]/div/label[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ No, the proxy isnt required to be enabled selected",
                sleep_after=time_sleep
            )
            
            print("⏳ Inserting LAMS title & URL now ⏳")
            log("⏳ Inserting LAMS title & URL now ⏳")
            
            #*** 19) Enter Monitor URL
            if True:
                time.sleep(0.5)
                el = WebDriverWait(driver, time_sleep).until(
                    EC.visibility_of_element_located((By.XPATH,
                        "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[2]/div/input"
                    ))
                )
                highlight(el)
                el.clear()
                el.send_keys(lams_student_url)
                #dramatic_input(el, lams_monitor_url)
                print("✅ Monitor URL entered")
                log("✅ Monitor URL entered")
                time.sleep(time_sleep)
            
            #*** 20) Enter Lesson Title
            if True: #to group the lines of code
                el = WebDriverWait(driver, time_sleep).until(
                    EC.visibility_of_element_located((By.XPATH,
                        "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[2]/form/div[2]/div[3]/div/input"
                    ))
                )
                highlight(el)
                el.clear()
                el.send_keys(lams_student_title)
                #dramatic_input(el, LAMS_Lesson_Title_2)
                print("✅ Title entered")
                time.sleep(time_sleep)

            #*** 21) Scroll the message box to the bottom
            if True: #to group the lines of code
                modal = WebDriverWait(driver, time_out).until(
                    EC.presence_of_element_located((By.ID, "event-resource-modal"))
                )
                highlight(modal)
                driver.execute_script(
                    "arguments[0].scrollTop = arguments[0].scrollHeight;",
                    modal
                )
                print("✅ Modal scrolled to bottom")
                log("✅ Modal scrolled to bottom")
                time.sleep(time_sleep)
                time.sleep(0.5)
            
            #*** 22) Enter Description
            time.sleep(0.5)
            if True: #to group the lines of code
                iframe = driver.find_element(
                    By.CSS_SELECTOR,
                    "#cke_event-resource-link-description iframe.cke_wysiwyg_frame"
                )
                driver.switch_to.frame(iframe)
                print("✅ Switched to iframe")
                log("✅ Switched to iframe")

                editor_body = driver.find_element(
                    By.CSS_SELECTOR,
                    "body[contenteditable='true']"
                )
                highlight(editor_body)
                try:
                    editor_body.clear()
                except:
                    editor_body.send_keys(Keys.COMMAND + "a", Keys.DELETE)
                
                editor_body.send_keys(lams_student_title)
                #dramatic_input(editor_body, LAMS_Lesson_Title_2)
                driver.switch_to.default_content()
                print("✅ Description added")
                log("✅ Description added")
                time.sleep(time_sleep)

            # 23) Save Resource
            time.sleep(0.5)
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[3]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Resource saved",
                sleep_after=time_sleep
            )

            # 24) Close
            time.sleep(0.5)
            wait_and_click(
                driver,
                "/html/body/div[1]/div/div[3]/div/div[7]/div[1]/div[6]/div/div/div/div[3]/button[1]",
                timeout=time_out,
                highlight_fn=highlight,
                message="✅ Closed attachment dialog",
                sleep_after=time_sleep
            )
        # Final summary
        print("🎉 Resource added successfully for ⬇️")
        print("   Elentra Event Name: "+ elentra_event_name)
        print("   Elentra Event URL : "+ elentra_event_url)

        log("🎉 Resource added successfully for ⬇️")
        log("   Elentra Event Name: "+ elentra_event_name)
        log("   LAMS Lesson ID    : "+ lams_lesson_id)
        
        if use_monitor:
            print("   LAMS Lesson Title  : "+ lams_monitor_title)
            print("   LAMS Monitor URL  : "+ lams_monitor_url)
            log("   LAMS Lesson Title : "+ lams_monitor_title)
            log("   LAMS Monitor URL  : "+ lams_monitor_url)

        if use_student:
            print("   LAMS Student Title : "+ lams_student_title)
            print("   LAMS Student URL  : "+ lams_student_url)
            log("   LAMS Student Title : "+ lams_student_title)
            log("   LAMS Student URL  : "+ lams_student_url)

    except Exception as e:
            print("❌ Resource not added successfully:", e)
            log(f"❌ Resource not added successfully:,{e}")

    finally:
            # driver.quit()
            elapsed = time.time() - start_time
            print(f"⏱ Total elapsed time: {elapsed:.1f} seconds")
            log(f"⏱ Total elapsed time: {elapsed:.1f} seconds")
            w.config(state="normal")

# — when OK is pressed, disable inputs, queue the automation, but do NOT destroy
def selenium_start():
# ensure any previous session is stopped
# 1) make sure at least one of the two URLs is requested
    if not (Upload_Monitor_URL_checkbox.get() or Upload_Student_URL_checkbox.get()):
        messagebox.showerror(
        "Selection error",
        "Please select at least one of:\n"
        "  • Upload Monitor URL\n"
        "  • Upload Student URL"
        )
        return

# 2) make sure none of the three text fields is blank
    if not Elentra_Event_entry.get().strip() \
    or not LAMS_Lesson_ID_entry.get().strip() \
    or not LAMS_Lesson_Title_entry.get().strip():
        messagebox.showerror(
            "Input error",
            "Please fill in:\n"
            "  • Elentra Event ID\n"
            "  • LAMS Lesson ID\n"
            "  • LAMS Lesson Title"
        )
        return

# 3) everything’s valid, so disable inputs and kick off the robot
    set_selenium_controls("normal")
    
    log("🏁 I want to end my work early....")
    # log_var.set("🏁 Starting Clifford Bot…\n")
    root.after(100, lambda: run_upload_elentra_link(
        Elentra_Event_entry.get().strip(),
        LAMS_Lesson_ID_entry.get().strip(),
        LAMS_Lesson_Title_entry.get().strip(),
        Upload_Monitor_URL_checkbox.get(),
        Upload_Student_URL_checkbox.get()
    ))
    notebook.select(selenium_frame) # switch back to selenium tab

def selenium_stop():
    # 1) if you’ve already created a Selenium driver, tear it down
    if 'driver' in globals() and driver:
        try:
            driver.quit()
        except Exception:
            pass
    sel_start_btn.config(state="normal")
    sel_stop_btn.config(state="Normal")
    set_selenium_controls("normal")
    set_controls(True)
    log("🛑 Selenium stopped by user.")
    notebook.select(selenium_frame) # switch back to selenium tab

# ---- Initialize ----
switch_mode()
root.update()
root.minsize(root.winfo_width(), root.winfo_height())
root.resizable(False, False)
root.mainloop()
